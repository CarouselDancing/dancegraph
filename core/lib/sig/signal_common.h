/** @file signal_common.h

Structs and classes common to signal code
*/

#pragma once

#include <chrono>
#include <string>
#include <functional>

#include <magic_enum/magic_enum.hpp>
#define SIGNAL_LOCAL_CLIENTID -1

#include <nlohmann/json.hpp>

namespace spdlog
{
	class logger;
}

namespace net
{
	// Different signal types
	enum class SignalType : uint8_t
	{
		Control = 0,	// e.g. new connection		
		Environment, // e.g. toggle music
		Client,
	};
	// Hardcoded, should use magic_enum instead
	constexpr int kNumSignalTypes = magic_enum::enum_count<SignalType>();
}

namespace sig
{
	struct SignalIpcProperties
	{
		std::string name;
		int numEntries = 100;
	};

	// Alias for a signal time point
	using time_point = std::chrono::time_point<std::chrono::system_clock>;

	// Get the time now
	time_point time_now();
	// Get duration between 2 time points
	double duration_sec(const sig::time_point& t0, const sig::time_point& t1);
	// Convert time point to string
	std::string time_point_as_string(const sig::time_point& tp);

	enum class SignalPathway
	{
		Passthru=0, // producer 
		Full, // producer -> state -> network -> state -> consumer
	};

	// Support multiple stages for the signal's representation
	enum SignalStage
	{
		Producer = 0, // signal as generated by the producer
		State,		// signal as stored in the state of clients/server
		Network,	// signal, traveling through the network
		Consumer	// signal, as read by the consumer
	};


	// Signalheader to record various useful IDs to transferred info	
	// DO NOT USE THIS FOR ANY ONGOING CODE
	// Just for legacy code when using the undumper consumer and test programs
	struct SignalHeader {
		
		int userID;
		unsigned long long timestamp; // milliseconds since epoch
		int packetID;
		int dataSize;
		
	};
	

	enum SignalIndex {
		Test = 0,
		ZedCam,
		Mic,
		Haptic
	};


	/**
	* \struct SignalProperties
	* The sig::SignalProperties struct is passed into the Config module to be populated, and then subsequently passed into the producers and consumers.
	*
	*/
	

	struct SignalProperties
	{
		
		/** A string of arbitrary JSON(not a filename) for passing options to be fed to the producers, consumersand transformers
		* This may be used to indicate, say, buffer names for IPC transfer or similar.
		*/
		std::string jsonConfig = "{}";


		/** For some generic producers, the signal type is not known so this is where we tell the producer what signal it's making!
		*/
		std::string signalType;

		/** A flag to indicate whether the signal should be sent over the network using reliable packets (i.e. with TCP-style acknowledgements).
		* This significantly affects latency.
		*/
		bool isReliable = false; 

		net::SignalType channelType;
		int signalIndex;

		/** Flag to indicate whether signal state is kept while reading / broadcasting or consuming
		* Typically, this should be set when using, say, prediction. 
		* Avoid using it when the signal is data-heavy, like microphone data
		*/

		bool keepState = true; 

		// Whether we send the locally produced signals right back to the local consumers
		bool isReflexive = false;

		/** A passthru signal is not getting transformed anywhere in the pipeline(we just memcpy the signals for all transformers)
		* If we set ANY of the data transformers below, set this to false
		*/
		bool isPassthru = true;

		// What's the max size of the datastream in its different forms? Producer -> state -> network -> state -> consumer
		// Useful for allocation purposes
		int producerFormMaxSize = 0;
		int stateFormMaxSize = 0;
		int consumerFormMaxSize = 0;
		int networkFormMaxSize = 0;


		int consumerFormMaxSizeWithHeader = 0;
		int networkFormMaxSizeWithHeader = 0;

		static void to_string_default(std::string&, const uint8_t*, int, SignalStage);


		
		/** A helper function to populate the various internal data size functions throughout the signal management process.
		* Populate this with the size of the bare data signal (i.e. not including Metadata)
		*/
		void set_all_sizes(int datasize);

		// Data transformation functions, allowing for compression etc
		// By default, a simple memcpy
		// Later, replace with an interface, which MIGHT need to know about the world and/or client state! That might be too much for a HW signal-producing DLL
		// If we change ANY of the below, set passthru to false
		// Thse functions should NOT know anything about signal metadata; they are purely for signal data transformation
		using data_xform = std::function<int(const uint8_t* src, int srcSize, uint8_t* dst, int dstMaxSize, const void* userData)>;
		static int data_xform_memcpy(const uint8_t* src, int srcSize, uint8_t* dst, int dstMaxSize, const void* userData);

		// These are all the data tranformation "edges" in the signal transport graph, between producer, consumer, state and network
		//    Paths: 
		//		 Producer -> [State|Network]
		//		 Network  -> [State|Consumer]
		//		 State    -> Network
		data_xform stateToNetwork = data_xform_memcpy; 
		data_xform networkToState = data_xform_memcpy;
		data_xform stateToConsumer = data_xform_memcpy;
		data_xform producerToState = data_xform_memcpy;  
		data_xform producerToNetwork = data_xform_memcpy; 
		data_xform networkToConsumer = data_xform_memcpy; 

		// TODO: Fix the copy constructor issue when this is invoked via undump 

		std::function<void(std::string&, const uint8_t *, int, SignalStage)> toString = to_string_default;

		// ... more parameters? Expected rate, etc

		// We need access to the calling process logger, so that log level etc can all be controlled externally
		std::shared_ptr<spdlog::logger> logger;

		// IPC-related properties
		SignalIpcProperties ipcProperties;
	};

	// Info that the consumer needs, at the initialization stage
	/** 
	* \struct SignalConsumerRuntimeConfig
	* 
	* A struct for passing parameters to the consumer initialization call at runtime
	* 
	*/
	struct SignalConsumerRuntimeConfig
	{		
		std::string producer_type;		//!< Signal type string of the produced signal
		std::string producer_name;		//!< Name of the producer

		int client_index;				//!< Index of the client. Local user is -1

		//!< Serializes properties into a JSON bundle
		nlohmann::json toJson() {
			nlohmann::json sJs = { { "producer",  producer_type },
						{"name", producer_name},
						{"client_idx", client_index} };
			return sJs;
		}
		
		bool metadata_override = true; //!< Set if you want to signal to the consumer to not alter the signal metadata (e.g. for file replay)

	};

	
	
	/**
	* \struct SignalMetadata
	*
	* Struct containing information that the consumer needs every time we send a packet
	* 
	*/

	struct SignalMetadata
	{

		time_point acquisitionTime;	//!< Timestamp placed by the first acquisition at the sender (i.e. after being collected by the producer)
		uint32_t packetId = 0;		//!< Packet Index
		int16_t userIdx = -1;		//!< Index of user; defaults to -1 for local client		
		uint8_t sigIdx = -1;		//!< Index of signal in scene, as per the scene configuration : up to 256 signals per scene
		
		uint8_t sigType = 0;		//!< Type of signal: control, client or environment

	};

	std::string get_unique_shared_library_path_for_loading(const std::string& path);
}